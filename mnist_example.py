# -*- coding: utf-8 -*-
"""CNN MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14YB2h3vxvxOanJc1yDDEqw0O4atiz7Rm
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms
import numpy as np
from torch.utils.data import TensorDataset, DataLoader
from sklearn.preprocessing import MinMaxScaler
from PIL import Image
import matplotlib.image as mpimg
import matplotlib.pyplot as plt

torch.manual_seed(42)


class model_s(nn.Module):
    def __init__(self):
        super(model_s, self).__init__()

        self.model = nn.Sequential(
            nn.Conv2d(1, 32, kernel_size=3, stride=2, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=2, padding=1),
            nn.ReLU(),
            nn.Conv2d(64, 128, kernel_size=3, stride=2, padding=1),
            nn.ReLU(),
            nn.Flatten(),
            nn.Dropout(0.4),
            nn.Linear(2048, 10)  # Assuming input image size is 28x28
        )
        # Output layers
        #self.adv_layer = nn.Sequential(nn.Linear(10, 1), nn.Sigmoid())

    def forward(self, img):
        label = self.model(img)
        #validity = self.adv_layer(label)
       # z_x = torch.sum(torch.exp(label), dim=-1, keepdim=True)
      #  d_x = z_x / (z_x + 1)

        return label

def im_convert(tensor):
  image = tensor.to("cpu").clone().detach()
  image = image.numpy().squeeze()
  return image

class Net(nn.Module):
  def __init__(self):
    super(Net,self).__init__()
    self.conv1 = nn.Conv2d(1,10,kernel_size=5,stride=1)
    self.conv2 = nn.Conv2d(10,10,kernel_size=5,stride=1)
    self.pool = nn.MaxPool2d(kernel_size=2,stride=2) #2x2 maxpool
    self.fc1 = nn.Linear(4*4*10,100)
    self.fc2 = nn.Linear(100,10)
  
  def forward(self,x):
    x = F.relu(self.conv1(x)) #24x24x10
    x = self.pool(x) #12x12x10
    x = F.relu(self.conv2(x)) #8x8x10
    x = self.pool(x) #4x4x10    
    x = x.view(-1, 4*4*10) #flattening
    x = F.relu(self.fc1(x))
    x = self.fc2(x)
    return x

dataloader = torch.utils.data.DataLoader(
    datasets.MNIST(
        "data/mnist",
        train=True,
        download=True,
        transform=transforms.Compose(
            [transforms.Resize(32), transforms.ToTensor(), transforms.Normalize([0.5], [0.5])]
        ),
    ),
    batch_size=1,
    shuffle=True,
)
labeled_imgs = []
labeled_labels = []
unlabeled_imgs = []
unlabeled_labels = []

# Initialize a counter for each class
class_counter = [0] * 10

# Iterate through the dataset
for images, labels in dataloader:
    # Extract the class label
    label = int(labels)

    # Check if the class has less than ten samples already
    s=torch.rand(1)
    if (s>=0.5 and class_counter[label] < 10):
        labeled_imgs.append(images)
        labeled_labels.append(labels)
        class_counter[label] += 1
    else:
        unlabeled_imgs.append(images)
        unlabeled_labels.append(labels)

# Concatenate the lists to create labeled and unlabeled datasets
labeled_dataset = torch.utils.data.TensorDataset(torch.cat(labeled_imgs), torch.cat(labeled_labels))
unlabeled_dataset = torch.utils.data.TensorDataset(torch.cat(unlabeled_imgs), torch.cat(unlabeled_labels))

print(f"Number of labeled samples: {len(labeled_dataset)}")
print(f"Number of unlabeled samples: {len(unlabeled_dataset)}")
dataloader = DataLoader(dataset=labeled_dataset, batch_size=32, shuffle=True)
dataloader_unlabeled = DataLoader(dataset=unlabeled_dataset, batch_size=100, shuffle=True)
batch_size = 8
validation_split = .1
shuffle_dataset = True
random_seed= 2
s=iter(dataloader)
test_loader = torch.utils.data.DataLoader(
    datasets.MNIST(
        "data/mnist",
        train=False,
        download=False,
        transform=transforms.Compose(
            [transforms.Resize(32), transforms.ToTensor(), transforms.Normalize([0.5], [0.5])]
        ),
    ),
    batch_size=8,
    shuffle=False,
)

model = model_s().cuda()
print(dataloader.dataset)
print(test_loader.dataset)
print(model)
iter_target=iter(dataloader)
sample,label=next(iter_target)
print(sample.shape,sample.mean(),sample.var(),sample.min(),sample.max())
print(label.shape)

iter_test=iter(test_loader)
sample_test,label_test=next(iter_test)
print(sample_test.min(),sample_test.max())

optimizer= torch.optim.Adam(model.parameters(), lr=0.0002, betas=(0.5,0.999 ))
criterion = nn.CrossEntropyLoss()

train_errors = []
train_acc = []
val_errors = []
val_acc = []
n_train = len(dataloader.dataset)
print("length of training data",n_train)
# n_val = len(validation_loader)*batch_size

for i in range(300):
  print(i)
  total_loss = 0
  total_acc = 0  
  c = 0
  for images,labels in dataloader:
    images = images.cuda()
    labels = labels.cuda()
    
    optimizer.zero_grad()
    output = model(images)
    loss = criterion(output,labels)
    loss.backward()
    optimizer.step()
    
    total_loss+=loss.item()
    total_acc+=torch.sum(torch.max(output,dim=1)[1]==labels).item()*1.0    
    c+=1
    
  
  #validation
  
  # total_loss_val = 0
  # total_acc_val = 0
  # c = 0
  # for images,labels in validation_loader:
  #   images = images.cuda()
  #   labels = labels.cuda()
  #   output = model(images)
  #   loss = criterion(output,labels)
    
  #   total_loss_val +=loss.item()
  #   total_acc_val +=torch.sum(torch.max(output,dim=1)[1]==labels).item()*1.0
  #   c+=1
  
  # train_errors.append(total_loss/n_train)
  # train_acc.append(total_acc/n_train)
  # val_errors.append(total_loss_val/n_val)
  # val_acc.append(total_acc_val/n_val)
  
print("Trainig complete")

# fig, ax = plt.subplots(nrows=1, ncols=2)
# ax[0].plot(train_errors, 'r',label="Train")
# ax[0].plot(val_errors, 'g', label="Validation")
# ax[0].set_title("Grafik error")
# ax[0].set_ylabel("Error (cross-entropy)")
# ax[0].set_xlabel("Epoch")
# ax[0].legend()
# ax[1].plot(train_acc, 'r',label="Train")
# ax[1].plot(val_acc, 'g', label="Validation")
# ax[1].set_title("Grafik akurasi")
# ax[1].set_ylabel("Accuracy")
# ax[1].set_xlabel("Epoch")
# ax[1].legend()
# plt.show()

total_acc = 0
for images,labels in test_loader:
  images = images.cuda()
  labels = labels.cuda()
  output = model(images)
  total_acc+=torch.sum(torch.max(output,dim=1)[1]==labels).item()*1.0

print("Test accuracy :",total_acc/len(test_loader.dataset))
